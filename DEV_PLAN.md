# libco-oop 开发计划

## AI助手协作指南

### 指令格式标准
每个开发任务的AI助手提示词遵循以下格式：
- **任务背景**: 简要说明当前任务的技术背景和目标
- **具体要求**: 明确的功能和技术实现要求
- **文件路径**: 精确的文件创建/修改路径
- **参考实现**: 指向libco/libaco的相关实现参考
- **验证方法**: 如何验证任务完成的具体标准
- **依赖检查**: 需要确认的前置条件

### 执行流程
1. **确认前置条件**: 检查依赖和环境配置
2. **复制AI提示词**: 使用标准格式的提示词
3. **执行AI指令**: 让AI助手完成具体实现
4. **验证执行结果**: 运行测试和质量检查
5. **标记任务状态**: 更新进度跟踪表

### 任务状态定义
- 🔲 未开始 (Not Started)
- 🔄 进行中 (In Progress)
- ✅ 已完成 (Completed)
- ⚠️ 需要返工 (Needs Rework)
- ✔️ 已验证 (Verified)

## 开发进度跟踪

### 当前版本: 1.0 - 最小可行版本

| 任务编号 | 任务名称 | 状态 | 开始时间 | 完成时间 | 备注 |
|---------|---------|------|----------|----------|------|
| TASK001 | 项目基础设施搭建 | ✔️ 已验证 | 2025-01-14 | 2025-01-14 | 目录结构、构建系统、测试框架全部完成 |
| TASK001.1 | 创建项目目录结构 | ✅ 已完成 | 2025-01-14 | 2025-01-14 | 14个目录+README文件创建完成 |
| TASK001.2 | 配置构建系统 | ✅ 已完成 | 2025-01-14 | 2025-01-14 | xmake配置完成，支持C++17，无警告编译 |
| TASK001.3 | 设置测试框架 | ✅ 已完成 | 2025-01-14 | 2025-01-14 | Google Test框架配置完成，7个基础测试通过 |
| TASK002 | 协程上下文管理实现 | 🔲 未开始 | - | - | 等待开始 |
| TASK003 | 协程栈管理系统 | 🔲 未开始 | - | - | 等待开始 |
| TASK004 | 基础协程类实现 | 🔲 未开始 | - | - | 等待开始 |
| TASK005 | 简单调度器实现 | 🔲 未开始 | - | - | 等待开始 |

### 完成情况统计
- **总任务数**: 5 (1.0版本)
- **已完成**: 1 (20%)
- **进行中**: 0 (0%)
- **未开始**: 4 (80%)

### 最近更新
- **2025-01-14**: TASK001完全完成并验证，项目基础设施搭建完成
  - 创建了完整的目录结构 (14个目录)
  - 配置了xmake构建系统，支持C++17标准
  - 设置了Google Test测试框架，7个基础测试全部通过
  - 构建系统优化，编译无警告无错误
  - 准备开始TASK002协程上下文管理实现


## 版本规划概述

本项目采用渐进式开发模式，分为三个主要版本：
- **1.0 版本**: 最小可行版本 (MVP) - 基础协程功能
- **2.0 版本**: 增强版本 - IO调度和高级特性
- **3.0 版本**: 完整版本 - 生产就绪的完整功能

每个版本按开发顺序划分为具体任务，采用 TASK001 格式编号。

## 技术架构决策

### 核心设计理念
1. **混合栈管理**: 结合libco共享栈和libaco独立栈的优势
2. **分层调度**: 基础调度 → IO调度 → 智能调度的渐进架构
3. **现代C++**: 使用C++17特性，RAII和移动语义
4. **测试驱动**: 每个功能都先写测试，再写实现

### 与libco/libaco的技术对比
| 特性 | libco | libaco | libco-oop |
|------|-------|--------|-----------|
| 栈管理 | 共享栈 | 独立栈 | 混合策略 |
| 上下文切换 | 传统保存 | 优化保存 | 可配置模式 |
| 接口风格 | C风格 | C风格 | 现代C++面向对象 |
| 调度策略 | 简单调度 | 无调度器 | 分层智能调度 |
| 内存管理 | 手动管理 | 手动管理 | RAII自动管理 |

---

## 1.0 版本 - 最小可行版本

### TASK001: 项目基础设施搭建
**版本**: 1.0
**状态**: ✔️ 已验证
**优先级**: 高
**预计时间**: 2-3小时
**实际时间**: 2小时
**完成日期**: 2025-01-14

#### 技术决策说明
**为什么这样设计**:
- 采用标准C++项目目录结构，便于维护和扩展
- 分离公共头文件和内部实现，提供清晰的API边界
- 建立完整的测试体系，支持TDD开发模式
- 使用xmake构建系统，支持跨平台和依赖管理

**关键技术点**:
- 目录结构要支持头文件的分层管理
- 测试框架要支持单元测试、集成测试和性能测试
- 构建系统要支持调试和发布两种模式
- 文档结构要支持API文档和教程文档

#### 前置条件检查清单
执行本任务前，请确认：
- [ ] 当前在项目根目录 `/home/xtong/self_proj/libco-oop`
- [ ] 有目录创建和文件写入权限
- [ ] git仓库已初始化
- [ ] xmake已安装并可用

**检查命令**:
```bash
# 确认当前目录
pwd

# 检查权限
touch test_permission && rm test_permission

# 检查git状态
git status

# 检查xmake
xmake --version
```

#### 子任务清单

##### 1.1 创建项目目录结构
**执行时间**: 5分钟
**任务状态**: ✅ 已完成
**完成时间**: 2025-01-14

**AI助手提示词**:
```
请帮我创建 libco-oop 项目的完整目录结构。

任务背景：搭建协程库项目的标准目录结构，遵循现代C++项目最佳实践，为后续的协程实现提供清晰的代码组织。

具体要求：
1. 创建以下目录结构：
   - include/libco_oop/ (公共头文件，对外API)
   - include/internal/ (内部头文件，实现细节)
   - src/core/ (核心协程实现)
   - src/scheduler/ (调度器实现)
   - src/io/ (IO事件处理实现)
   - src/utils/ (工具类和辅助函数)
   - tests/unit/ (单元测试)
   - tests/integration/ (集成测试)
   - tests/benchmark/ (性能基准测试)
   - docs/api/ (API参考文档)
   - docs/tutorial/ (使用教程)
   - docs/design/ (设计文档)
   - examples/ (示例代码)
   - tools/ (开发和调试工具)

2. 在每个目录下创建 .gitkeep 文件确保目录被版本控制跟踪

3. 在主要目录下创建 README.md 文件说明目录用途：
   - src/README.md (源代码组织说明)
   - tests/README.md (测试策略说明)
   - docs/README.md (文档结构说明)
   - examples/README.md (示例代码说明)

文件路径：在项目根目录 /home/xtong/self_proj/libco-oop 下创建

验证方法：
- 使用 `find . -type d | sort` 确认目录结构完整
- 使用 `find . -name ".gitkeep" | wc -l` 确认.gitkeep文件数量
- 确认主要目录都有README.md文件

依赖检查：
- 确认当前目录是项目根目录
- 确认有写入权限
```

**验收标准**:
- [ ] 所有目录创建成功
- [ ] 每个目录都有.gitkeep文件
- [ ] 主要目录都有README.md说明
- [ ] 目录结构符合C++项目规范

**完成标记**: ✅ 已完成

##### 1.2 配置构建系统
**执行时间**: 15分钟
**任务状态**: ✅ 已完成
**完成时间**: 2025-01-14

**AI助手提示词**:
```
请帮我配置 libco-oop 项目的 xmake 构建系统。

任务背景：建立现代化的C++构建系统，支持协程库的编译、测试和性能基准测试，为后续开发提供稳定的构建环境。

具体要求：
1. 修改现有的 xmake.lua 文件，配置基础编译环境：
   - 设置 C++17 标准 (协程库需要现代C++特性)
   - 优化编译选项：调试模式(-g -O0)，发布模式(-O2 -DNDEBUG)
   - 警告选项：-Wall -Wextra -Werror (严格的代码质量要求)
   - 包含目录：include/ 和 include/internal/
   - 支持汇编文件编译 (协程上下文切换需要汇编代码)

2. 配置构建目标：
   - libco_oop 静态库：编译 src/ 下的所有 .cpp 和 .S 文件
   - unit_tests 可执行文件：链接 libco_oop 和 gtest
   - benchmark_tests 可执行文件：链接 libco_oop 和 benchmark
   - examples 目录下的示例程序

3. 配置依赖包管理：
   - gtest (Google Test框架，用于单元测试)
   - benchmark (Google Benchmark，用于性能测试)
   - 配置包管理器自动下载和链接

4. 配置构建模式：
   - debug 模式：启用调试信息，禁用优化，启用AddressSanitizer
   - release 模式：启用优化，禁用调试信息
   - coverage 模式：启用代码覆盖率统计

文件路径：修改项目根目录下的 xmake.lua

参考实现：参考现代C++项目的xmake配置最佳实践

验证方法：
- 运行 `xmake config --mode=debug` 确认调试模式配置
- 运行 `xmake config --mode=release` 确认发布模式配置
- 运行 `xmake show` 查看配置详情
- 运行 `xmake build` 确认能正常编译

依赖检查：
- 确认 xmake 已安装且版本 >= 2.6.0
- 确认网络连接正常 (用于下载依赖包)
```

**验收标准**:
- [ ] xmake.lua 配置完成
- [ ] 支持 debug/release 两种模式
- [ ] 能够成功编译静态库
- [ ] 测试目标配置正确
- [ ] 依赖包能正常下载和链接

**完成标记**: ✅ 已完成

##### 1.3 设置测试框架
**执行时间**: 20分钟
**任务状态**: ✅ 已完成
**完成时间**: 2025-01-14

**AI助手提示词**:
```
请帮我为 libco-oop 项目设置 Google Test 测试框架。

任务背景：建立完整的测试基础设施，支持TDD开发模式，为协程库的各个组件提供可靠的测试环境。

具体要求：
1. 在 tests/unit/ 目录下创建测试基础设施：
   - test_main.cpp：测试主函数，初始化测试环境
   - test_helper.h：测试辅助工具和通用测试函数
   - test_basic.cpp：第一个示例测试文件，验证测试框架工作

2. 创建测试辅助工具 (test_helper.h)：
   - 内存泄漏检测辅助函数
   - 协程测试用的简单函数
   - 性能测试计时辅助
   - 测试数据生成工具

3. 编写基础测试用例 (test_basic.cpp)：
   - 测试项目能正常编译和链接
   - 测试基本的 C++17 功能 (如 std::function, lambda)
   - 验证测试框架本身正常工作
   - 测试项目目录结构的完整性

4. 在 tests/benchmark/ 目录下创建性能测试基础：
   - bench_main.cpp：性能测试主函数
   - bench_helper.h：性能测试辅助工具

5. 创建测试配置文件：
   - tests/unit/CMakeLists.txt (如果需要)
   - tests/README.md：测试策略和运行方法说明

文件路径：
- tests/unit/test_main.cpp
- tests/unit/test_helper.h
- tests/unit/test_basic.cpp
- tests/benchmark/bench_main.cpp
- tests/benchmark/bench_helper.h

参考实现：参考Google Test官方文档和最佳实践

验证方法：
- 运行 `xmake build` 确认测试程序能编译
- 运行 `xmake run unit_tests` 确认单元测试能运行
- 运行 `xmake run benchmark_tests` 确认性能测试能运行
- 检查测试输出格式是否正确

依赖检查：
- 确认 xmake.lua 已正确配置 gtest 和 benchmark
- 确认目录结构已创建完成
```

**验收标准**:
- [ ] 测试框架基础设施创建完成
- [ ] 能够成功编译测试程序
- [ ] 基础测试用例能够运行并通过
- [ ] 性能测试框架能够正常工作
- [ ] 测试输出格式清晰易读

**完成标记**: ✅ 已完成

#### 任务完成验证
**功能验证**:
```bash
# 编译整个项目
xmake build

# 运行单元测试
xmake run unit_tests

# 运行性能测试
xmake run benchmark_tests

# 检查代码质量
xmake check
```

**质量检查**:
- [ ] 代码编译无警告
- [ ] 所有测试用例通过
- [ ] 测试覆盖率统计正常
- [ ] 内存检查无泄漏

**文档更新**:
- [ ] README.md 已更新构建和测试说明
- [ ] tests/README.md 已创建测试说明
- [ ] 变更日志已记录

#### 注意事项
- 确保目录结构符合 C++ 项目最佳实践
- 构建系统要支持增量编译和并行构建
- 测试框架要易于扩展新的测试用例
- 所有配置文件要有详细注释
- 测试要能在CI/CD环境中自动运行

---

### TASK002: 协程上下文管理实现
**版本**: 1.0
**状态**: 🔲 未开始
**优先级**: 高
**预计时间**: 4-6小时

#### 技术决策说明
**为什么这样设计**:
- 上下文切换是协程的核心机制，直接影响性能
- 结合libco的稳定性和libaco的高性能优化
- 使用现代C++封装，提供类型安全和RAII管理
- 支持可配置的寄存器保存策略，平衡性能和兼容性

**关键技术点**:
- x86_64汇编的寄存器保存和恢复
- 栈指针的正确切换和对齐
- FPU/SSE状态的可选保存
- 信号安全性考虑 (避免libco的信号处理问题)

**与libco/libaco对比**:
- libco: 传统的14个寄存器保存，稳定但略重
- libaco: 优化的寄存器保存，高性能但复杂
- libco-oop: 可配置的保存策略，兼顾性能和稳定性

#### 前置条件检查清单
执行本任务前，请确认：
- [ ] TASK001 已完成并验证
- [ ] 项目能够正常编译
- [ ] 了解x86_64汇编基础知识
- [ ] 已研究libco和libaco的上下文切换实现

**检查命令**:
```bash
# 确认项目结构
ls -la include/libco_oop/ src/core/

# 确认编译环境
xmake build

# 确认参考代码存在
ls -la reference/libco/coctx* reference/libaco/aco*
```

#### 子任务清单

##### 2.1 定义上下文数据结构
**执行时间**: 30分钟
**任务状态**: 🔲 未开始

**AI助手提示词**:
```
请帮我设计和实现 libco-oop 的协程上下文管理系统。

任务背景：实现协程的核心上下文切换机制，这是协程库的基础。需要结合libco的稳定性和libaco的高性能，设计现代C++风格的上下文管理接口。

具体要求：
1. 在 include/libco_oop/context.h 中定义 Context 类：
   - 参考 reference/libco/coctx.h 的寄存器定义
   - 参考 reference/libaco/aco.h 的优化策略
   - 设计现代C++面向对象接口
   - 支持 x86_64 平台 (后续可扩展其他平台)

2. 定义上下文数据结构：
   - CPU通用寄存器状态 (rax, rbx, rcx, rdx, rsi, rdi, rbp, rsp, r8-r15)
   - 栈指针和栈大小管理
   - 可选的FPU/SSE状态保存 (通过编译选项控制)
   - 上下文有效性标记

3. 设计核心接口方法：
   - Context() - 构造函数，初始化空上下文
   - ~Context() - 析构函数，清理资源
   - save() - 保存当前执行上下文
   - restore() - 恢复到指定上下文
   - swap(Context& other) - 原子性的上下文切换
   - is_valid() const - 检查上下文是否有效
   - reset() - 重置上下文状态

4. 设计配置选项：
   - 支持精简模式 (类似libaco，只保存必要寄存器)
   - 支持完整模式 (类似libco，保存所有寄存器)
   - 支持FPU状态保存的开关

文件路径：include/libco_oop/context.h

参考实现：
- reference/libco/coctx.h (寄存器定义)
- reference/libaco/aco.h (优化策略)
- 现代C++的RAII和移动语义

验证方法：
- 编译检查头文件语法正确
- 确认接口设计符合C++最佳实践
- 检查与libco/libaco的兼容性

依赖检查：
- 确认 include/libco_oop/ 目录存在
- 确认参考代码可访问
```

**验收标准**:
- [ ] Context 类接口设计完成
- [ ] 头文件编译无错误
- [ ] 接口设计符合现代C++规范
- [ ] 支持可配置的保存策略
- [ ] 文档注释完整

**完成标记**: 🔲 (完成后改为 ✅)

##### 2.2 实现上下文切换汇编代码
**执行时间**: 90分钟
**任务状态**: 🔲 未开始

**AI助手提示词**:
```
请帮我实现协程上下文切换的汇编代码。

任务背景：实现协程上下文切换的核心汇编函数，这是协程性能的关键部分。需要参考libco和libaco的实现，但要避免已知的问题（如libco的信号处理问题）。

具体要求：
1. 在 src/core/ 目录下创建 context_switch.S 文件：
   - 实现 context_swap 汇编函数，符合System V ABI
   - 参考 reference/libco/coctx_swap.S 的寄存器保存策略
   - 参考 reference/libaco/acosw.S 的优化技巧
   - 支持 x86_64 平台，使用 AT&T 汇编语法

2. 汇编函数实现要求：
   - 函数签名：void context_swap(Context* from, Context* to)
   - 保存/恢复必要的寄存器：rax, rbx, rcx, rdx, rsi, rdi, rbp, rsp, r8-r15
   - 可选保存FPU/SSE状态 (通过宏控制)
   - 正确处理栈指针切换和对齐
   - 保证函数调用约定的正确性
   - 添加详细的汇编注释，解释每行代码的作用

3. 在 src/core/context.cpp 中实现 C++ 包装：
   - 实现 Context 类的构造函数和析构函数
   - 实现 Context::swap() 方法，调用汇编函数
   - 实现 save(), restore(), is_valid(), reset() 方法
   - 添加必要的错误检查和边界验证
   - 实现调试和诊断功能

4. 安全性考虑：
   - 避免libco中的信号处理问题
   - 确保栈指针始终有效
   - 添加上下文有效性检查
   - 处理异常情况和错误恢复

文件路径：
- src/core/context_switch.S (汇编实现)
- src/core/context.cpp (C++包装)

参考实现：
- reference/libco/coctx_swap.S (寄存器保存策略)
- reference/libaco/acosw.S (性能优化技巧)
- System V ABI 文档 (调用约定)

验证方法：
- 编译检查汇编代码语法正确
- 运行简单的上下文切换测试
- 验证寄存器状态保存/恢复正确性
- 检查栈指针切换的正确性

依赖检查：
- 确认 Context 类头文件已定义
- 确认汇编器支持 x86_64
- 确认参考代码可访问
```

**验收标准**:
- [ ] 汇编代码编译无错误
- [ ] C++包装实现完成
- [ ] 基本的上下文切换功能正常
- [ ] 寄存器状态保存/恢复正确
- [ ] 代码注释详细清晰

**完成标记**: 🔲 (完成后改为 ✅)

##### 2.3 编写上下文管理测试
**执行时间**: 60分钟
**任务状态**: 🔲 未开始

**AI助手提示词**:
```
请帮我为协程上下文管理编写全面的测试用例。

任务背景：为上下文切换功能编写完整的测试套件，确保上下文切换的正确性和稳定性，这是协程库可靠性的基础。

具体要求：
1. 在 tests/unit/ 目录下创建 test_context.cpp：
   - 使用Google Test框架
   - 测试 Context 类的所有公共接口
   - 验证上下文切换的正确性和性能
   - 包含边界条件和错误处理测试

2. 核心测试用例：
   - BasicContextCreation: 测试Context对象的创建和销毁
   - SimpleContextSwap: 测试基本的上下文切换功能
   - RegisterPreservation: 验证寄存器状态在切换后保持不变
   - StackSwitching: 测试栈指针切换的正确性
   - MultipleSwaps: 测试多次连续切换的稳定性
   - ErrorHandling: 测试无效上下文的错误处理

3. 高级测试用例：
   - NestedContextSwap: 测试嵌套的上下文切换
   - LargeDataPreservation: 测试大量数据在切换后的保持
   - PerformanceBenchmark: 基本的性能基准测试
   - MemoryLeakDetection: 内存泄漏检测

4. 创建测试辅助工具：
   - RegisterChecker: 用于验证寄存器状态的辅助类
   - TestCoroutineFunction: 模拟协程执行的测试函数
   - MemoryTracker: 内存使用情况跟踪
   - PerformanceTimer: 性能测试计时器

5. 测试数据和场景：
   - 使用不同的寄存器值模式进行测试
   - 测试不同大小的栈数据
   - 模拟真实的协程使用场景

文件路径：tests/unit/test_context.cpp

参考实现：
- Google Test最佳实践
- libco和libaco的测试策略
- 现代C++测试技巧

验证方法：
- 运行 `xmake run unit_tests --filter=Context*` 执行上下文测试
- 检查测试覆盖率是否达到90%以上
- 验证所有测试用例都能通过
- 确认性能测试结果在合理范围内

依赖检查：
- 确认 Context 类实现已完成
- 确认测试框架已配置
- 确认能够编译和运行测试
```

**验收标准**:
- [ ] 测试文件创建完成
- [ ] 所有基本功能测试通过
- [ ] 寄存器保存/恢复验证正确
- [ ] 性能测试结果合理
- [ ] 测试覆盖率达到90%以上

**完成标记**: 🔲 (完成后改为 ✅)

#### 任务完成验证
**功能验证**:
```bash
# 编译上下文模块
xmake build libco_oop

# 运行上下文测试
xmake run unit_tests --filter=Context*

# 运行性能基准测试
xmake run benchmark_tests --filter=Context*

# 检查内存泄漏
valgrind --leak-check=full xmake run unit_tests --filter=Context*
```

**质量检查**:
- [ ] 代码编译无警告
- [ ] 所有测试用例通过
- [ ] 内存检查无泄漏
- [ ] 性能测试达到预期
- [ ] 代码覆盖率达标

**文档更新**:
- [ ] API文档已更新
- [ ] 设计文档已记录上下文切换原理
- [ ] 示例代码已创建

#### 注意事项
- 汇编代码要考虑不同编译器的兼容性
- 上下文切换要保证原子性和线程安全
- 要处理好栈对齐问题 (16字节对齐)
- 考虑调试信息的保留和符号表
- 测试要覆盖异常情况和边界条件
- 性能测试要在不同优化级别下验证

---

### TASK003: 协程栈管理系统
**版本**: 1.0
**状态**: 🔲 未开始
**优先级**: 高
**预计时间**: 3-4小时

#### 技术决策说明
**为什么这样设计**:
- 栈管理是协程内存使用的关键，直接影响性能和安全性
- 结合libco的共享栈和libaco的独立栈优势
- 实现智能的栈分配策略，根据使用模式自动优化
- 提供栈保护机制，防止栈溢出导致的内存破坏

**关键技术点**:
- 内存对齐和栈保护页设置
- 栈使用情况监控和统计
- 不同栈分配策略的性能权衡
- 栈溢出检测和恢复机制

**与libco/libaco对比**:
- libco: 共享栈节省内存，但切换开销大
- libaco: 独立栈切换快，但内存占用多
- libco-oop: 混合策略，智能选择最优方案

#### 前置条件检查清单
执行本任务前，请确认：
- [ ] TASK002 已完成并验证
- [ ] 上下文切换功能正常工作
- [ ] 了解内存管理和mmap/mprotect系统调用
- [ ] 已研究libco和libaco的栈管理策略

**检查命令**:
```bash
# 确认上下文切换测试通过
xmake run unit_tests --filter=Context*

# 检查系统调用支持
man mmap mprotect

# 确认内存页大小
getconf PAGESIZE
```

#### 子任务清单

##### 3.1 设计栈管理接口
**执行时间**: 45分钟
**任务状态**: 🔲 未开始

**AI助手提示词**:
```
请帮我设计 libco-oop 的协程栈管理系统。

任务背景：实现高效且安全的协程栈管理，支持多种栈分配策略，为协程提供可靠的执行环境。需要结合libco和libaco的优势，设计现代C++风格的栈管理接口。

具体要求：
1. 在 include/libco_oop/stack.h 中定义栈管理类：
   - Stack 类：表示单个协程栈，管理栈内存生命周期
   - StackAllocator 接口：栈分配器抽象基类
   - FixedStackAllocator：固定大小栈分配器实现
   - SharedStackAllocator：共享栈分配器实现 (类似libco)

2. Stack 类设计要求：
   - 栈内存的RAII管理 (构造时分配，析构时释放)
   - 栈边界保护 (guard page) 防止栈溢出
   - 栈使用情况监控和统计
   - 栈溢出检测和报告
   - 支持栈内存的预分配和复用

3. StackAllocator 接口设计：
   - allocate(size_t size) - 分配指定大小的栈
   - deallocate(Stack* stack) - 释放栈内存
   - get_statistics() - 获取分配统计信息
   - set_options(const StackOptions& opts) - 设置分配选项

4. 栈分配策略：
   - 固定大小策略：每个协程独立栈，大小固定
   - 共享栈策略：多个协程共享栈，动态保存/恢复
   - 混合策略：根据协程特性自动选择策略

5. 安全特性：
   - 栈保护页 (使用mprotect设置不可访问页)
   - 栈溢出检测 (检查栈指针边界)
   - 内存对齐 (确保16字节对齐)
   - 资源泄漏防护

文件路径：include/libco_oop/stack.h

参考实现：
- reference/libco/co_routine_inner.h (共享栈设计)
- reference/libaco/aco.c (独立栈管理)
- 现代C++的RAII和智能指针

验证方法：
- 编译检查头文件语法正确
- 确认接口设计符合C++最佳实践
- 检查与Context类的兼容性

依赖检查：
- 确认 Context 类已实现
- 确认 include/libco_oop/ 目录存在
```

**验收标准**:
- [ ] Stack 和 StackAllocator 类设计完成
- [ ] 头文件编译无错误
- [ ] 接口设计支持多种分配策略
- [ ] 安全特性设计完整
- [ ] 文档注释详细

**完成标记**: 🔲 (完成后改为 ✅)

##### 3.2 实现栈分配器
**执行时间**: 90分钟
**任务状态**: 🔲 未开始

**AI助手提示词**:
```
请帮我实现协程栈分配器的核心功能。

任务背景：实现高效且安全的栈内存分配器，支持栈保护和统计功能，为协程提供可靠的栈内存管理。

具体要求：
1. 在 src/core/stack.cpp 中实现：
   - Stack 类的完整实现
   - FixedStackAllocator 类的完整实现
   - SharedStackAllocator 类的基础实现

2. Stack 类实现：
   - 构造函数：分配栈内存，设置保护页
   - 析构函数：清理栈内存和保护页
   - get_base() - 获取栈底地址
   - get_top() - 获取栈顶地址
   - get_size() - 获取栈大小
   - is_valid() - 检查栈是否有效
   - check_overflow() - 检查栈溢出

3. FixedStackAllocator 实现：
   - allocate() - 分配固定大小的协程栈
   - deallocate() - 释放协程栈
   - 内存对齐的栈分配 (16字节对齐)
   - 使用mmap分配栈内存
   - 使用mprotect设置栈保护页

4. 栈保护机制：
   - 在栈底设置guard page (不可读写页)
   - 栈溢出时触发SIGSEGV信号
   - 提供栈溢出检测函数
   - 支持栈使用情况监控

5. 统计和监控：
   - 跟踪已分配的栈数量
   - 监控栈内存使用情况
   - 提供栈使用统计信息
   - 检测内存泄漏

6. 错误处理：
   - 内存分配失败的优雅处理
   - 栈溢出的检测和报告
   - 资源泄漏的防护机制
   - 异常安全保证

文件路径：src/core/stack.cpp

参考实现：
- reference/libaco/aco.c (栈分配策略)
- reference/libco/co_routine.cpp (共享栈机制)
- Linux mmap/mprotect 系统调用文档

验证方法：
- 编译检查实现代码
- 运行基本的栈分配测试
- 验证栈保护页功能
- 检查内存使用情况

依赖检查：
- 确认 Stack 类头文件已定义
- 确认系统支持 mmap/mprotect
- 确认编译环境正确配置
```

**验收标准**:
- [ ] Stack 类实现完成
- [ ] FixedStackAllocator 实现完成
- [ ] 栈保护页功能正常
- [ ] 内存对齐正确
- [ ] 统计功能工作正常

**完成标记**: 🔲 (完成后改为 ✅)

##### 3.3 栈管理测试用例
**执行时间**: 60分钟
**任务状态**: 🔲 未开始

**AI助手提示词**:
```
请为栈管理系统编写全面的测试用例。

任务背景：为栈管理功能编写完整的测试套件，确保栈分配、保护和统计功能的正确性和可靠性。

具体要求：
1. 在 tests/unit/test_stack.cpp 中创建测试：
   - 使用Google Test框架
   - 测试所有栈管理类的公共接口
   - 验证栈保护机制的有效性
   - 包含性能和压力测试

2. 核心测试用例：
   - BasicStackAllocation: 测试基本的栈分配和释放
   - StackAlignment: 验证栈内存的对齐要求
   - GuardPageProtection: 测试栈保护页功能
   - StackOverflowDetection: 测试栈溢出检测
   - MultipleStackAllocation: 测试多个栈的并发分配
   - StackStatistics: 验证栈使用统计功能

3. 安全测试用例：
   - GuardPageAccess: 测试访问保护页是否触发错误
   - StackBoundaryCheck: 测试栈边界检查功能
   - MemoryLeakDetection: 检测栈分配的内存泄漏
   - ResourceCleanup: 验证资源清理的正确性

4. 性能测试用例：
   - AllocationPerformance: 栈分配/释放的性能基准
   - MemoryEfficiency: 内存使用效率测试
   - ScalabilityTest: 大量栈分配的可扩展性测试

5. 测试辅助工具：
   - StackTester: 栈功能测试辅助类
   - MemoryMonitor: 内存使用监控工具
   - PerformanceProfiler: 性能分析工具

文件路径：tests/unit/test_stack.cpp

验证方法：
- 运行 `xmake run unit_tests --filter=Stack*` 执行栈测试
- 检查测试覆盖率是否达到90%以上
- 验证所有测试用例都能通过
- 确认性能测试结果合理

依赖检查：
- 确认 Stack 类实现已完成
- 确认测试框架已配置
- 确认能够处理信号 (栈溢出测试)
```

**验收标准**:
- [ ] 测试文件创建完成
- [ ] 所有功能测试通过
- [ ] 栈保护机制验证正确
- [ ] 性能测试结果合理
- [ ] 测试覆盖率达到90%以上

**完成标记**: 🔲 (完成后改为 ✅)

#### 任务完成验证
**功能验证**:
```bash
# 编译栈管理模块
xmake build libco_oop

# 运行栈管理测试
xmake run unit_tests --filter=Stack*

# 运行性能基准测试
xmake run benchmark_tests --filter=Stack*

# 检查内存泄漏
valgrind --leak-check=full xmake run unit_tests --filter=Stack*
```

**质量检查**:
- [ ] 代码编译无警告
- [ ] 所有测试用例通过
- [ ] 内存检查无泄漏
- [ ] 栈保护功能正常
- [ ] 性能达到预期目标

#### 注意事项
- 栈大小要考虑实际使用需求 (建议默认64KB-1MB)
- 栈保护页要正确设置权限 (PROT_NONE)
- 要考虑内存碎片问题，使用内存池优化
- 栈分配要线程安全，考虑多线程环境
- 栈溢出检测要及时且准确
- 考虑不同操作系统的兼容性

---

### TASK004: 基础协程类实现
**版本**: 1.0
**状态**: 🔲 未开始
**优先级**: 高
**预计时间**: 4-5小时

#### 技术决策说明
**为什么这样设计**:
- Coroutine类是协程库的核心用户接口，需要易用且高效
- 结合Context和Stack的底层实现，提供高级抽象
- 使用现代C++特性，提供类型安全和异常安全
- 支持多种协程函数类型，提高灵活性

**关键技术点**:
- 协程状态机的正确实现
- 协程函数的包装和调用
- 异常处理和资源清理
- 与底层组件的集成

**与libco/libaco对比**:
- libco: C风格接口，手动资源管理
- libaco: C风格接口，简单状态管理
- libco-oop: 现代C++接口，自动资源管理，完整状态机

#### 前置条件检查清单
执行本任务前，请确认：
- [ ] TASK002 和 TASK003 已完成并验证
- [ ] Context 和 Stack 类功能正常
- [ ] 了解协程的生命周期和状态转换
- [ ] 熟悉现代C++的RAII和移动语义

**检查命令**:
```bash
# 确认底层组件测试通过
xmake run unit_tests --filter=Context*
xmake run unit_tests --filter=Stack*

# 检查头文件结构
ls -la include/libco_oop/
```

#### 子任务清单

##### 4.1 设计 Coroutine 类接口
**执行时间**: 60分钟
**任务状态**: 🔲 未开始

**AI助手提示词**:
```
请帮我设计 libco-oop 的核心 Coroutine 类。

任务背景：设计协程库的核心用户接口，提供现代C++风格的协程创建、执行和管理功能。这是用户直接使用的主要接口，需要易用、安全且高效。

具体要求：
1. 在 include/libco_oop/coroutine.h 中定义：
   - Coroutine 类的完整接口
   - CoroutineState 枚举 (Ready, Running, Suspended, Finished, Error)
   - 协程函数类型定义和包装器

2. 协程状态管理：
   - Ready: 协程已创建，准备执行
   - Running: 协程正在执行
   - Suspended: 协程已暂停，等待恢复
   - Finished: 协程已完成执行
   - Error: 协程执行出错

3. 类设计要求：
   - 支持 std::function<void()> 协程函数
   - 支持函数指针和lambda表达式
   - RAII 资源管理 (自动管理Context和Stack)
   - 移动语义支持 (不可复制，可移动)
   - 异常安全保证

4. 核心接口方法：
   - static create() - 静态工厂方法创建协程
   - resume() - 恢复协程执行
   - yield() - 暂停当前协程 (静态方法)
   - get_state() const - 获取协程状态
   - is_finished() const - 检查是否完成
   - get_id() const - 获取协程唯一ID

5. 高级功能：
   - 支持协程参数传递和返回值
   - 支持协程异常处理
   - 支持协程调试信息
   - 支持协程性能统计

文件路径：include/libco_oop/coroutine.h

参考实现：
- reference/libco/co_routine.h (接口设计)
- reference/libaco/aco.h (状态管理)
- 现代C++协程库的最佳实践

验证方法：
- 编译检查头文件语法正确
- 确认接口设计符合C++最佳实践
- 检查与Context和Stack类的兼容性

依赖检查：
- 确认 Context 和 Stack 类已实现
- 确认 include/libco_oop/ 目录存在
```

**验收标准**:
- [ ] Coroutine 类接口设计完成
- [ ] 状态枚举定义正确
- [ ] 头文件编译无错误
- [ ] 接口设计现代化且易用
- [ ] 文档注释完整

**完成标记**: 🔲 (完成后改为 ✅)

##### 4.2 实现协程执行逻辑
**执行时间**: 120分钟
**任务状态**: 🔲 未开始

**AI助手提示词**:
```
请帮我实现 Coroutine 类的核心执行逻辑。

任务背景：实现协程的创建、执行、暂停和恢复机制，这是协程库的核心用户接口。需要集成之前实现的Context和Stack组件，提供完整的协程生命周期管理。

具体要求：
1. 在 src/core/coroutine.cpp 中实现 Coroutine 类：
   - 实现构造函数和析构函数，确保RAII资源管理
   - 实现 create() 静态工厂方法
   - 实现 resume() 和 yield() 核心方法
   - 实现协程状态管理和转换

2. 协程创建逻辑：
   - create() 方法接受协程函数和栈大小参数
   - 分配协程栈 (使用Stack类)
   - 初始化协程上下文 (使用Context类)
   - 设置协程入口函数和参数
   - 返回智能指针管理的协程对象

3. 协程执行逻辑：
   - resume() 方法：从当前协程切换到目标协程
   - yield() 静态方法：暂停当前协程，返回调用者
   - 正确处理协程状态转换 (Ready→Running→Suspended/Finished)
   - 集成Context::swap()进行上下文切换

4. 协程函数包装：
   - 实现协程入口函数包装器
   - 处理协程函数的调用和返回
   - 协程完成时自动设置Finished状态
   - 处理协程异常和错误情况

5. 状态管理：
   - 维护协程状态机的正确转换
   - 提供状态查询接口 (get_state(), is_finished())
   - 实现协程ID管理和唯一性
   - 支持协程调试信息

6. 异常安全设计决策：
   - 协程函数异常的捕获和处理策略
   - 资源清理的异常安全保证 (强异常安全性)
   - 状态一致性的维护 (使用RAII确保状态正确性)
   - 异常传播机制 (协程内异常如何传递给调用者)

7. 性能考虑：
   - 协程创建的内存分配优化
   - 状态切换的原子性保证
   - 减少不必要的内存拷贝
   - 支持move语义提高效率

文件路径：src/core/coroutine.cpp

参考实现：
- reference/libco/co_routine.cpp (协程创建和切换)
- reference/libaco/aco.c (协程状态管理)
- 现代C++的异常安全和RAII原则
- Boost.Coroutine2的异常处理策略

验证方法：
- 编译检查实现代码语法正确
- 运行基本的协程创建和执行测试
- 验证协程状态转换的正确性
- 检查资源管理无泄漏
- 测试异常安全性 (协程函数抛异常时的行为)
- 验证性能指标 (协程创建 < 1μs，切换 < 20ns)

依赖检查：
- 确认 Context 和 Stack 类已实现并测试通过
- 确认 Coroutine 头文件已定义
- 确认能够正常编译和链接
- 确认异常处理测试框架可用
```

**验收标准**:
- [ ] Coroutine 类实现完成
- [ ] 协程创建和执行功能正常
- [ ] 状态管理正确
- [ ] 异常处理完善 (强异常安全性)
- [ ] 资源管理无泄漏
- [ ] 性能指标达到预期

**完成标记**: 🔲 (完成后改为 ✅)

##### 4.3 协程功能测试
**执行时间**: 90分钟
**任务状态**: 🔲 未开始

**AI助手提示词**:
```
请为 Coroutine 类编写全面的测试用例。

任务背景：为协程核心功能编写完整的测试套件，确保协程创建、执行、状态管理的正确性和可靠性。这是验证协程库核心功能的关键测试。

具体要求：
1. 在 tests/unit/test_coroutine.cpp 中创建测试：
   - 使用Google Test框架
   - 测试 Coroutine 类的所有公共接口
   - 验证协程生命周期的完整性
   - 包含复杂场景和边界条件测试

2. 核心测试用例：
   - BasicCoroutineCreation: 测试协程的创建和销毁
   - SimpleCoroutineExecution: 测试基本的协程执行流程
   - CoroutineYieldResume: 测试协程的暂停和恢复
   - CoroutineStateTransition: 验证状态转换的正确性
   - CoroutineCompletion: 测试协程正常完成的处理
   - CoroutineException: 测试协程异常处理

3. 高级测试用例：
   - MultipleCoroutines: 测试多个协程的创建和管理
   - NestedCoroutineCalls: 测试协程的嵌套调用
   - CoroutineResourceManagement: 验证资源管理的正确性
   - CoroutinePerformance: 基本的性能基准测试

4. 测试辅助工具：
   - CoroutineTester: 协程测试辅助类
   - TestCoroutineFunctions: 各种测试用的协程函数
   - StateTracker: 协程状态变化跟踪器
   - ResourceMonitor: 资源使用监控工具

5. 集成测试：
   - 与Context和Stack组件的集成测试
   - 验证协程切换的正确性
   - 测试协程栈的使用情况
   - 验证上下文保存和恢复

文件路径：tests/unit/test_coroutine.cpp

参考实现：
- Google Test最佳实践
- libco和libaco的测试策略
- 协程库的典型测试场景

验证方法：
- 运行 `xmake run unit_tests --filter=Coroutine*` 执行协程测试
- 检查测试覆盖率是否达到90%以上
- 验证所有测试用例都能通过
- 确认性能测试结果合理

依赖检查：
- 确认 Coroutine 类实现已完成
- 确认 Context 和 Stack 测试通过
- 确认测试框架正常工作
```

**验收标准**:
- [ ] 测试文件创建完成
- [ ] 所有核心功能测试通过
- [ ] 协程状态转换验证正确
- [ ] 集成测试通过
- [ ] 测试覆盖率达到90%以上

**完成标记**: 🔲 (完成后改为 ✅)

#### 任务完成验证
**功能验证**:
```bash
# 编译协程模块
xmake build libco_oop

# 运行协程测试
xmake run unit_tests --filter=Coroutine*

# 运行性能基准测试
xmake run benchmark_tests --filter=Coroutine*

# 检查内存泄漏
valgrind --leak-check=full xmake run unit_tests --filter=Coroutine*
```

**质量检查**:
- [ ] 代码编译无警告
- [ ] 所有测试用例通过
- [ ] 内存检查无泄漏
- [ ] 协程状态管理正确
- [ ] 性能达到预期目标

**文档更新**:
- [ ] API文档已更新
- [ ] 协程使用示例已创建
- [ ] 设计文档已记录协程实现原理

#### 注意事项
- 协程函数异常要正确处理，避免资源泄漏
- 协程状态转换要原子性，确保线程安全
- 要支持协程的嵌套调用和复杂场景
- 考虑协程调试信息的保留和查询
- 性能要达到预期目标，与libco/libaco对比

---

### TASK005: 简单调度器实现
**版本**: 1.0
**状态**: 🔲 未开始
**优先级**: 中
**预计时间**: 3-4小时

#### 技术决策说明
**为什么这样设计**:
- 调度器是协程库的核心组件，负责协程的调度和执行管理
- 采用分层设计，从简单调度开始，为后续IO调度打基础
- 支持多种调度策略，提供灵活的调度算法
- 使用现代C++设计，提供类型安全和扩展性

**关键技术点**:
- 协程队列的高效管理
- 调度算法的公平性和性能
- 调度器状态的一致性维护
- 与协程生命周期的正确集成

**与libco/libaco对比**:
- libco: 简单的协程调度，基于调用栈
- libaco: 无内置调度器，需要用户实现
- libco-oop: 完整的调度器框架，支持多种策略

#### 前置条件检查清单
执行本任务前，请确认：
- [ ] TASK001-004 已完成并验证
- [ ] Coroutine 类功能正常
- [ ] 了解调度算法和数据结构
- [ ] 熟悉协程的生命周期管理

**检查命令**:
```bash
# 确认协程功能测试通过
xmake run unit_tests --filter=Coroutine*

# 检查项目结构
ls -la src/scheduler/ include/libco_oop/
```

#### 子任务清单

##### 5.1 设计调度器接口
**执行时间**: 45分钟
**任务状态**: 🔲 未开始

**AI助手提示词**:
```
请帮我设计 libco-oop 的基础调度器系统。

任务背景：实现协程调度器的核心接口，负责协程的调度和执行管理。这是协程库从单个协程扩展到多协程并发执行的关键组件。

具体要求：
1. 在 include/libco_oop/scheduler.h 中定义调度器类：
   - Scheduler 基类：调度器抽象接口
   - SimpleScheduler 类：简单轮询调度器实现
   - SchedulerPolicy 枚举：调度策略定义
   - 任务队列管理接口

2. 核心接口设计：
   - schedule(Coroutine* co) - 添加协程到调度队列
   - run() - 运行调度循环，执行就绪协程
   - stop() - 停止调度器
   - get_running_coroutine() - 获取当前运行协程
   - get_statistics() - 获取调度统计信息

3. 调度策略支持：
   - RoundRobin: 轮询调度，公平分配CPU时间
   - Priority: 优先级调度 (为后续扩展预留)
   - FIFO: 先进先出调度
   - 可扩展的调度策略接口

4. 任务队列设计：
   - 就绪队列：存储可执行的协程
   - 等待队列：存储暂停的协程 (为IO调度预留)
   - 完成队列：存储已完成的协程
   - 线程安全的队列操作

5. 调度器状态管理：
   - Running: 调度器正在运行
   - Stopped: 调度器已停止
   - Idle: 调度器空闲，无协程可调度
   - 状态转换的原子性保证

文件路径：include/libco_oop/scheduler.h

参考实现：
- reference/libco/co_routine.cpp (调度逻辑)
- 现代调度器设计原理
- C++并发编程最佳实践

验证方法：
- 编译检查头文件语法正确
- 确认接口设计符合调度器原理
- 检查与Coroutine类的兼容性

依赖检查：
- 确认 Coroutine 类已实现
- 确认 include/libco_oop/ 目录存在
```

**验收标准**:
- [ ] Scheduler 类接口设计完成
- [ ] 调度策略枚举定义正确
- [ ] 头文件编译无错误
- [ ] 接口设计可扩展
- [ ] 文档注释完整

**完成标记**: 🔲 (完成后改为 ✅)

##### 5.2 实现基础调度逻辑
**执行时间**: 90分钟
**任务状态**: 🔲 未开始

**AI助手提示词**:
```
请帮我实现基础的协程调度器。

任务背景：实现简单但完整的协程调度器，支持多个协程的轮询调度，为协程库提供基础的并发执行能力。

具体要求：
1. 在 src/scheduler/scheduler.cpp 中实现：
   - Scheduler 基类的通用功能
   - SimpleScheduler 类的完整实现
   - 轮询调度算法的核心逻辑

2. SimpleScheduler 实现：
   - 构造函数：初始化调度器状态和队列
   - schedule() 方法：将协程添加到就绪队列
   - run() 方法：实现调度循环，轮询执行协程
   - stop() 方法：优雅停止调度器
   - 协程状态变化的处理

3. 调度循环逻辑：
   - 从就绪队列取出协程
   - 切换到协程执行 (调用 resume())
   - 处理协程执行后的状态变化
   - 根据状态决定协程的后续处理
   - 将仍需执行的协程重新入队

4. 状态管理：
   - 维护当前运行协程的引用
   - 处理协程完成后的清理
   - 调度器状态的线程安全更新
   - 统计信息的收集和维护

5. 错误处理：
   - 协程执行异常的捕获和处理
   - 调度器状态异常的恢复
   - 资源泄漏的防护
   - 调试信息的记录

6. 性能优化：
   - 高效的队列操作 (使用无锁队列或优化的std::queue)
   - 减少不必要的内存分配 (对象池复用)
   - 优化调度开销 (减少系统调用)
   - 支持调度统计和分析 (CPU时间片统计)

7. 调度公平性保证：
   - 实现时间片轮转机制
   - 防止协程饥饿现象
   - 支持协程优先级 (为后续扩展预留)
   - 负载均衡策略

8. 扩展性设计：
   - 支持插件式调度算法
   - 预留IO调度器集成接口
   - 支持自定义调度策略
   - 模块化的组件设计

文件路径：src/scheduler/scheduler.cpp

参考实现：
- reference/libco/co_routine.cpp (协程调度)
- 操作系统调度器原理 (CFS, 时间片轮转)
- 高性能队列实现 (lock-free queue)
- Go语言goroutine调度器设计

验证方法：
- 编译检查实现代码
- 运行基本的多协程调度测试
- 验证调度公平性 (统计每个协程的执行时间)
- 检查资源管理正确性
- 测试调度器启停的正确性
- 验证性能指标 (调度延迟 < 100μs)

依赖检查：
- 确认 Scheduler 头文件已定义
- 确认 Coroutine 类功能正常
- 确认能够正常编译和链接
- 确认性能测试框架可用
```

**验收标准**:
- [ ] SimpleScheduler 实现完成
- [ ] 调度循环逻辑正确
- [ ] 多协程调度功能正常
- [ ] 状态管理正确
- [ ] 调度公平性得到保证
- [ ] 性能指标达到预期 (调度延迟 < 100μs)
- [ ] 扩展性设计完成

**完成标记**: 🔲 (完成后改为 ✅)

##### 5.3 调度器测试用例
**执行时间**: 60分钟
**任务状态**: 🔲 未开始

**AI助手提示词**:
```
请为调度器编写全面的测试用例。

任务背景：为协程调度器编写完整的测试套件，确保调度逻辑的正确性、公平性和稳定性。

具体要求：
1. 在 tests/unit/test_scheduler.cpp 中创建测试：
   - 使用Google Test框架
   - 测试调度器的所有核心功能
   - 验证多协程调度的正确性
   - 包含并发和压力测试

2. 核心测试用例：
   - BasicSchedulerCreation: 测试调度器的创建和销毁
   - SingleCoroutineScheduling: 测试单个协程的调度
   - MultipleCoroutineScheduling: 测试多个协程的轮询调度
   - SchedulerLifecycle: 测试调度器的启动和停止
   - CoroutineCompletion: 测试协程完成后的处理
   - SchedulerStatistics: 验证调度统计信息

3. 高级测试用例：
   - SchedulingFairness: 测试调度的公平性
   - SchedulerPerformance: 调度器性能基准测试
   - ConcurrentScheduling: 并发调度测试
   - SchedulerErrorHandling: 错误处理测试
   - ResourceManagement: 资源管理验证

4. 测试辅助工具：
   - SchedulerTester: 调度器测试辅助类
   - TestCoroutines: 各种测试用协程
   - SchedulingMonitor: 调度行为监控器
   - PerformanceProfiler: 性能分析工具

5. 集成测试：
   - 与Coroutine类的集成测试
   - 复杂协程交互场景测试
   - 长时间运行稳定性测试

文件路径：tests/unit/test_scheduler.cpp

验证方法：
- 运行 `xmake run unit_tests --filter=Scheduler*` 执行调度器测试
- 检查测试覆盖率是否达到90%以上
- 验证调度公平性和性能指标
- 确认所有测试用例通过

依赖检查：
- 确认 Scheduler 类实现已完成
- 确认 Coroutine 类功能正常
- 确认测试框架配置正确
```

**验收标准**:
- [ ] 测试文件创建完成
- [ ] 所有调度功能测试通过
- [ ] 调度公平性验证正确
- [ ] 性能测试达到预期
- [ ] 测试覆盖率达到90%以上

**完成标记**: 🔲 (完成后改为 ✅)

#### 任务完成验证
**功能验证**:
```bash
# 编译调度器模块
xmake build libco_oop

# 运行调度器测试
xmake run unit_tests --filter=Scheduler*

# 运行性能基准测试
xmake run benchmark_tests --filter=Scheduler*

# 检查内存泄漏
valgrind --leak-check=full xmake run unit_tests --filter=Scheduler*
```

**质量检查**:
- [ ] 代码编译无警告
- [ ] 所有测试用例通过
- [ ] 调度公平性验证通过
- [ ] 性能达到预期目标
- [ ] 内存检查无泄漏

#### 注意事项
- 调度器要处理协程异常，避免影响其他协程
- 调度算法要保证公平性，避免协程饥饿
- 要支持调度器的优雅停止和重启
- 考虑调度器的扩展性，为IO调度做准备
- 性能要达到预期，支持大量协程调度

---

##### 4.2 实现协程执行逻辑
- 实现协程的创建和初始化
- 实现 resume/yield 机制
- 处理协程完成和清理

**AI助手提示词**:
```
请帮我实现 Coroutine 类的核心功能：

1. 在 src/core/coroutine.cpp 中实现：
   - Coroutine 构造函数和析构函数
   - create() 静态方法
   - resume() 和 yield() 方法
   - 协程状态管理

2. 实现要点：
   - 协程函数的包装和调用
   - 上下文切换的集成
   - 异常处理和错误恢复
   - 资源清理和内存管理

3. 集成之前的组件：
   - 使用 Context 类进行上下文切换
   - 使用 Stack 类管理协程栈
   - 实现协程间的切换逻辑

请确保实现符合现代 C++ 的最佳实践。
```

##### 4.3 协程功能测试
- 创建协程基本功能测试
- 测试协程状态转换
- 验证资源管理正确性

**AI助手提示词**:
```
请为 Coroutine 类编写全面的测试用例：

1. 在 tests/unit/test_coroutine.cpp 中创建：
   - 基本的协程创建和执行测试
   - resume/yield 功能测试
   - 协程状态转换测试
   - 协程完成和清理测试

2. 测试场景：
   - 简单的协程执行流程
   - 多次 yield/resume 的协程
   - 协程异常处理
   - 协程资源泄漏检测

3. 集成测试：
   - 多个协程的创建和执行
   - 协程间的切换测试
   - 协程栈使用验证

请确保测试覆盖所有协程状态和转换。
```

#### 验收标准
- [ ] Coroutine 类接口设计完成
- [ ] 协程创建和执行功能实现
- [ ] resume/yield 机制正常工作
- [ ] 所有测试用例通过
- [ ] 协程状态管理正确

#### 注意事项
- 协程函数异常要正确处理
- 资源清理要在所有路径上执行
- 协程状态转换要原子性
- 要支持协程的嵌套调用

---

### TASK005: 简单调度器实现
**版本**: 1.0
**状态**: 计划中
**优先级**: 中

#### 任务描述
实现基础的协程调度器，支持协程的调度和执行管理。

#### 子任务清单

##### 5.1 设计调度器接口
- 定义 Scheduler 类接口
- 实现任务队列管理
- 设计调度策略接口

**AI助手提示词**:
```
请帮我设计 libco-oop 的基础调度器：

1. 在 include/libco_oop/scheduler.h 中定义：
   - Scheduler 类接口
   - 调度策略枚举 (RoundRobin, Priority 等)
   - 任务队列管理接口

2. 核心功能：
   - schedule() - 添加协程到调度队列
   - run() - 运行调度循环
   - stop() - 停止调度器
   - get_running_coroutine() - 获取当前运行协程

3. 设计要求：
   - 支持不同的调度策略
   - 线程安全的任务队列
   - 可扩展的调度算法

请设计一个简单但可扩展的调度器架构。
```

##### 5.2 实现基础调度逻辑
- 实现轮询调度算法
- 实现任务队列管理
- 处理协程完成和清理

**AI助手提示词**:
```
请帮我实现基础的协程调度器：

1. 在 src/scheduler/scheduler.cpp 中实现：
   - Scheduler 类的完整实现
   - 轮询 (Round-Robin) 调度算法
   - 任务队列的管理

2. 实现要点：
   - 维护就绪协程队列
   - 实现调度循环逻辑
   - 处理协程状态变化
   - 协程完成后的清理

3. 调度逻辑：
   - 从队列中取出就绪协程
   - 切换到协程执行
   - 处理协程 yield 后的状态
   - 将仍需执行的协程重新入队

请确保调度器能正确处理协程的生命周期。
```

##### 5.3 调度器测试用例
- 测试基本调度功能
- 验证多协程调度
- 测试调度器状态管理

**AI助手提示词**:
```
请为调度器编写全面的测试用例：

1. 在 tests/unit/test_scheduler.cpp 中创建：
   - 基本的调度器功能测试
   - 多协程调度测试
   - 调度器生命周期测试

2. 测试场景：
   - 单个协程的调度执行
   - 多个协程的轮询调度
   - 协程完成后的清理验证
   - 调度器停止和重启

3. 集成测试：
   - 结合前面实现的 Coroutine 类
   - 测试复杂的协程交互场景
   - 验证调度的公平性

请确保测试覆盖调度器的所有核心功能。
```

#### 验收标准
- [ ] Scheduler 类接口设计完成
- [ ] 基础调度算法实现
- [ ] 任务队列管理正常工作
- [ ] 所有测试用例通过
- [ ] 多协程调度功能正确

#### 注意事项
- 调度器要处理协程异常
- 任务队列要考虑线程安全
- 调度算法要公平和高效
- 要支持调度器的优雅停止

---

## 2.0 版本 - 增强版本

### TASK006: IO事件驱动调度
**版本**: 2.0
**状态**: 🔲 未开始
**优先级**: 高
**预计时间**: 5-6小时

#### 技术决策说明
**为什么这样设计**:
- IO事件驱动是高性能协程库的核心特性
- 基于epoll实现高效的IO多路复用
- 与协程调度器无缝集成，提供异步IO能力
- 支持网络编程和高并发服务器开发

**关键技术点**:
- epoll的边缘触发和水平触发模式
- IO事件与协程的绑定和唤醒机制
- 超时处理和错误恢复
- 与基础调度器的协调工作

**与libco/libaco对比**:
- libco: 提供co_epoll，但接口较为底层
- libaco: 无内置IO支持，需要用户实现
- libco-oop: 完整的IO事件驱动调度器，现代化接口

#### 架构决策记录 (ADR)

**ADR-001: IO多路复用技术选择**
- **决策**: 选择 epoll 作为主要的IO多路复用机制
- **背景**: 需要在select/poll/epoll/io_uring之间选择
- **备选方案**:
  - select: 兼容性好，但性能差，FD数量限制
  - poll: 无FD数量限制，但性能仍不理想
  - epoll: Linux平台高性能，支持边缘触发
  - io_uring: 最新技术，但兼容性问题
- **决策理由**: epoll在Linux平台性能最优，边缘触发模式适合高并发场景
- **后续扩展**: 保留接口抽象，后续可支持kqueue(macOS)和io_uring

**ADR-002: 事件驱动架构集成策略**
- **决策**: IOManager继承Scheduler，深度集成事件循环
- **背景**: 需要在松耦合和紧耦合之间选择
- **备选方案**:
  - 松耦合: IOManager作为独立组件，通过回调与调度器通信
  - 紧耦合: IOManager继承Scheduler，统一调度循环
- **决策理由**: 紧耦合方案性能更优，减少回调开销，便于统一管理
- **风险缓解**: 保持清晰的职责分离，预留扩展接口

**ADR-003: 边缘触发vs水平触发**
- **决策**: 默认使用水平触发，提供边缘触发选项
- **背景**: epoll支持两种触发模式，各有优劣
- **备选方案**:
  - 水平触发: 编程简单，不易出错，性能中等
  - 边缘触发: 性能更高，但编程复杂，容易出错
- **决策理由**: 水平触发更安全可靠，边缘触发作为高级选项
- **实现策略**: 提供配置选项，支持运行时切换

#### 前置条件检查清单
执行本任务前，请确认：
- [ ] TASK001-005 已完成并验证
- [ ] Scheduler 基础调度功能正常
- [ ] 了解epoll系统调用和IO多路复用
- [ ] 熟悉网络编程和异步IO概念

**检查命令**:
```bash
# 确认调度器测试通过
xmake run unit_tests --filter=Scheduler*

# 检查系统IO支持
man epoll_create epoll_ctl epoll_wait

# 检查项目结构
ls -la src/io/ include/libco_oop/
```

#### 子任务清单

##### 6.1 设计 IOManager 类
**执行时间**: 60分钟
**任务状态**: 🔲 未开始

**AI助手提示词**:
```
请帮我设计 libco-oop 的 IO 事件驱动调度器。

任务背景：实现基于epoll的IO事件驱动调度器，为协程提供高效的异步IO能力，支持网络编程和高并发应用开发。

具体要求：
1. 在 include/libco_oop/io_manager.h 中定义：
   - IOManager 类 (继承自 Scheduler)
   - IOEvent 结构体 (封装 IO 事件信息)
   - IOEventType 枚举 (读/写/错误事件类型)
   - 文件描述符管理接口

2. IOManager 核心接口：
   - add_event() - 添加 IO 事件监听
   - remove_event() - 移除 IO 事件监听
   - wait_for_io() - 协程等待 IO 事件
   - handle_events() - 处理就绪的 IO 事件
   - set_timeout() - 设置 IO 超时

3. IOEvent 结构设计：
   - fd: 文件描述符
   - events: 事件类型 (EPOLLIN/EPOLLOUT/EPOLLERR)
   - coroutine: 等待该事件的协程
   - timeout: 超时时间
   - callback: 事件回调函数 (可选)

4. 高级功能：
   - 支持边缘触发 (EPOLLET) 和水平触发模式
   - 支持一次性事件 (EPOLLONESHOT)
   - 支持事件优先级管理
   - 集成定时器功能

5. 与调度器集成：
   - 继承 Scheduler 的基础调度功能
   - 重写 run() 方法，集成 epoll_wait
   - 协程IO等待时的状态管理
   - IO事件就绪时的协程唤醒

文件路径：include/libco_oop/io_manager.h

参考实现：
- reference/libco/co_epoll.h (IO事件处理)
- Linux epoll 系统调用文档
- 现代异步IO库设计

验证方法：
- 编译检查头文件语法正确
- 确认接口设计符合IO编程模式
- 检查与Scheduler类的继承关系

依赖检查：
- 确认 Scheduler 类已实现
- 确认 include/libco_oop/ 目录存在
- 确认系统支持 epoll
```

**验收标准**:
- [ ] IOManager 类接口设计完成
- [ ] IOEvent 结构定义正确
- [ ] 头文件编译无错误
- [ ] 接口设计支持异步IO
- [ ] 文档注释完整

**完成标记**: 🔲 (完成后改为 ✅)

##### 6.2 实现 epoll 事件循环
**执行时间**: 120分钟
**任务状态**: 🔲 未开始

**AI助手提示词**:
```
请帮我实现 IO 事件驱动的调度器。

任务背景：实现基于epoll的高性能IO事件调度器，这是现代协程库的核心功能。需要将IO多路复用与协程调度完美融合，提供异步IO编程能力。

具体要求：
1. 在 src/io/io_manager.cpp 中实现：
   - IOManager 类的完整实现
   - epoll 文件描述符的生命周期管理
   - IO 事件与协程的精确关联机制

2. epoll系统调用封装：
   - epoll_create1() - 创建epoll实例，设置CLOEXEC
   - epoll_ctl() - 注册/修改/删除文件描述符
   - epoll_wait() - 等待IO事件就绪
   - 错误处理和资源清理

3. 事件管理核心逻辑：
   - add_event() - 添加IO事件监听，关联协程
   - remove_event() - 移除IO事件，取消协程关联
   - modify_event() - 修改事件类型和属性
   - handle_events() - 批量处理就绪事件

4. 调度循环集成：
   - 继承Scheduler的run()方法，集成IO等待
   - 平衡CPU密集型协程和IO密集型协程
   - 处理协程状态变化 (Running→Waiting→Ready)
   - 实现超时机制和超时协程唤醒

5. 高级特性实现：
   - 支持边缘触发和水平触发模式切换
   - 实现一次性事件 (EPOLLONESHOT) 支持
   - 支持事件优先级和批量处理
   - 集成信号处理 (signalfd) 支持

6. 性能优化策略：
   - 事件批量处理，减少系统调用开销
   - 使用内存池管理事件对象
   - 优化热路径，减少内存分配
   - 支持IO事件统计和性能分析

7. 错误处理和容错：
   - 处理EAGAIN/EWOULDBLOCK等常见IO错误
   - 文件描述符关闭时的清理机制
   - epoll实例异常时的恢复策略
   - 协程等待IO时的异常处理

文件路径：src/io/io_manager.cpp

参考实现：
- reference/libco/co_epoll.cpp (IO事件处理)
- Linux epoll系统调用手册
- nginx/libevent的事件循环设计
- Go netpoller的实现策略

验证方法：
- 编译检查实现代码语法正确
- 运行基本的IO事件注册和触发测试
- 验证协程IO等待和唤醒机制
- 测试边缘触发和水平触发模式
- 验证高并发场景下的稳定性
- 检查内存使用和性能指标

依赖检查：
- 确认 IOManager 头文件已定义
- 确认 Scheduler 基类功能正常
- 确认系统支持 epoll 系统调用
- 确认测试环境支持网络IO测试
```

**验收标准**:
- [ ] IOManager 类实现完成
- [ ] epoll事件循环正常工作
- [ ] IO事件注册和触发机制正确
- [ ] 协程IO等待和唤醒功能正常
- [ ] 支持边缘触发和水平触发模式
- [ ] 性能指标达到预期 (事件处理延迟 < 1ms)
- [ ] 高并发稳定性验证通过

**完成标记**: 🔲 (完成后改为 ✅)

##### 6.3 IO 调度器测试
- 测试 IO 事件注册和处理
- 验证协程 IO 等待机制
- 测试网络 IO 场景

**AI助手提示词**:
```
请为 IO 调度器编写全面的测试用例：

1. 在 tests/unit/test_io_manager.cpp 中创建：
   - IO 事件注册和注销测试
   - 协程 IO 等待测试
   - 网络 socket IO 测试

2. 测试场景：
   - pipe/socketpair 的读写测试
   - 多个协程同时等待不同 IO 事件
   - IO 超时处理测试
   - 错误条件处理

3. 集成测试：
   - 简单的 echo 服务器实现
   - 客户端-服务器通信测试
   - 并发连接处理测试

请确保测试覆盖各种 IO 场景和边界条件。
```

#### 验收标准
- [ ] IOManager 类设计和实现完成
- [ ] epoll 事件循环正常工作
- [ ] 协程 IO 等待机制实现
- [ ] 所有测试用例通过
- [ ] 能处理基本的网络 IO

#### 注意事项
- epoll 要正确处理边缘触发模式
- IO 事件要与协程正确关联
- 要处理 EAGAIN 等 IO 错误
- 考虑 IO 事件的优先级

---

### TASK007: 定时器系统实现
**版本**: 2.0
**状态**: 🔲 未开始
**优先级**: 中
**预计时间**: 4-5小时

#### 技术决策说明
**为什么这样设计**:
- 定时器是异步编程的重要组件，支持协程的定时唤醒和超时处理
- 高精度定时器为网络IO超时、任务调度等提供基础支持
- 与IO调度器深度集成，实现统一的事件驱动模型
- 支持大规模定时器场景，满足高并发服务器需求

**关键技术点**:
- 时间轮vs最小堆的算法选择和性能权衡
- 高精度时间管理和时间漂移处理
- 定时器与协程生命周期的绑定机制
- 系统时间变化的检测和处理

**与libco/libaco对比**:
- libco: 简单的超时机制，基于链表管理
- libaco: 无内置定时器支持
- libco-oop: 高精度、高性能的定时器系统

#### 架构决策记录 (ADR)

**ADR-004: 定时器数据结构选择**
- **决策**: 使用最小堆作为主要数据结构，时间轮作为优化选项
- **背景**: 需要在最小堆、时间轮、红黑树之间选择
- **备选方案**:
  - 最小堆: 插入O(logN)，取最小O(1)，适合精确定时
  - 时间轮: 插入O(1)，但精度受限于轮的粒度
  - 红黑树: 平衡的插入删除性能，但常数较大
- **决策理由**: 最小堆在大多数场景下性能最优，实现简单
- **扩展策略**: 保留时间轮接口，支持高频低精度场景

**ADR-005: 时间精度和漂移处理**
- **决策**: 支持毫秒级精度，使用单调时钟避免时间跳跃
- **背景**: 需要平衡精度需求和系统开销
- **技术选择**:
  - 使用 CLOCK_MONOTONIC 避免系统时间调整影响
  - 支持 std::chrono 的高精度时间类型
  - 实现时间校准机制处理时钟漂移
- **风险缓解**: 提供时间跳跃检测和恢复机制

#### 前置条件检查清单
执行本任务前，请确认：
- [ ] TASK005-006 已完成并验证
- [ ] IOManager 基础功能正常
- [ ] 了解定时器算法和高精度时间管理
- [ ] 熟悉 std::chrono 和系统时钟机制

**检查命令**:
```bash
# 确认调度器和IO管理器测试通过
xmake run unit_tests --filter=Scheduler*
xmake run unit_tests --filter=IOManager*

# 检查系统时钟支持
man clock_gettime

# 检查项目结构
ls -la src/scheduler/ include/libco_oop/
```

#### 子任务清单

##### 7.1 设计定时器接口
**执行时间**: 60分钟
**任务状态**: 🔲 未开始

**AI助手提示词**:
```
请帮我设计 libco-oop 的高精度定时器系统。

任务背景：实现协程库的定时器子系统，支持高精度的定时唤醒和超时处理。需要设计高效的定时器管理算法，与IO调度器深度集成。

具体要求：
1. 在 include/libco_oop/timer.h 中定义：
   - Timer 类 (单个定时器对象)
   - TimerManager 类 (定时器管理器)
   - TimerCallback 类型 (定时器回调函数)
   - TimerType 枚举 (一次性/周期性定时器)

2. Timer 类设计：
   - 唯一ID管理和生成
   - 到期时间和间隔时间
   - 关联的协程和回调函数
   - 定时器状态管理 (Active, Cancelled, Expired)
   - 支持RAII的生命周期管理

3. TimerManager 核心接口：
   - add_timer() - 添加定时器，返回Timer ID
   - cancel_timer() - 取消指定定时器
   - get_next_timeout() - 获取下次超时时间
   - process_timers() - 处理所有到期定时器
   - clear_expired() - 清理已过期的定时器

4. 高级功能设计：
   - 支持一次性和周期性定时器
   - 支持高精度时间 (毫秒级精度)
   - 支持定时器优先级管理
   - 支持批量定时器操作

5. 性能优化设计：
   - 高效的数据结构 (最小堆 + 时间轮混合)
   - 定时器对象池复用
   - 延迟删除和批量清理
   - 时间计算优化和缓存

6. 与调度器集成：
   - 预留IOManager集成接口
   - 支持协程定时唤醒机制
   - 提供sleep()和timeout()语义支持

文件路径：include/libco_oop/timer.h

参考实现：
- Linux内核定时器实现 (hrtimer)
- libevent的定时器管理
- Go语言timer的设计
- Boost.ASIO的deadline_timer

验证方法：
- 编译检查头文件语法正确
- 确认接口设计符合定时器使用模式
- 检查与IOManager的兼容性

依赖检查：
- 确认 IOManager 类已定义
- 确认 std::chrono 支持可用
- 确认 include/libco_oop/ 目录存在
```

**验收标准**:
- [ ] Timer 和 TimerManager 类设计完成
- [ ] 定时器接口支持多种使用场景
- [ ] 头文件编译无错误
- [ ] 接口设计可扩展且高效
- [ ] 文档注释完整

**完成标记**: 🔲 (完成后改为 ✅)

##### 7.2 实现定时器管理算法
- 实现最小堆或时间轮算法
- 处理定时器的添加和删除
- 实现高精度时间管理

**AI助手提示词**:
```
请帮我实现定时器管理系统：

1. 在 src/scheduler/timer.cpp 中实现：
   - TimerManager 类的完整实现
   - 选择最小堆或时间轮算法
   - 高精度时间计算和比较

2. 实现要点：
   - 定时器的高效插入和删除
   - 到期定时器的快速查找
   - 定时器 ID 的管理和复用
   - 内存管理和性能优化

3. 时间管理：
   - 使用 std::chrono 进行时间计算
   - 支持毫秒级精度
   - 处理系统时间变化

请确保定时器系统具有良好的性能特性。
```

##### 7.3 定时器集成和测试
- 将定时器集成到 IO 调度器
- 实现协程睡眠功能
- 编写定时器测试用例

**AI助手提示词**:
```
请帮我集成定时器系统并编写测试：

1. 集成到 IOManager：
   - 修改 IOManager 支持定时器
   - 在 epoll_wait 中使用定时器超时
   - 实现协程的 sleep() 功能

2. 在 tests/unit/test_timer.cpp 中创建测试：
   - 基本定时器功能测试
   - 大量定时器的性能测试
   - 定时器精度测试
   - 协程睡眠功能测试

3. 测试场景：
   - 不同超时时间的定时器
   - 定时器的取消和重置
   - 周期性定时器测试
   - 定时器与 IO 事件的交互

请确保定时器系统与调度器完美集成。
```

#### 验收标准
- [ ] Timer 和 TimerManager 类实现完成
- [ ] 定时器管理算法高效运行
- [ ] 与 IO 调度器集成成功
- [ ] 协程睡眠功能正常工作
- [ ] 所有测试用例通过

#### 注意事项
- 定时器精度要满足实际需求
- 要处理系统时间跳跃问题
- 定时器取消要及时生效
- 考虑定时器的内存开销

---

## 3.0 版本 - 完整版本

### TASK008: 协程池和资源管理
**版本**: 3.0
**状态**: 🔲 未开始
**优先级**: 高
**预计时间**: 4-5小时

#### 技术决策说明
**为什么这样设计**:
- 协程池是生产环境性能优化的关键组件，显著减少协程创建开销
- 智能的资源管理策略，平衡内存使用和性能需求
- 支持多种复用策略，适应不同的应用场景
- 提供详细的监控和调优接口，支持生产环境运维

**关键技术点**:
- 协程对象的完全重置和状态清理
- 智能的池大小调整算法
- 多线程环境下的无锁池管理
- 内存局部性优化和缓存友好设计

**与libco/libaco对比**:
- libco: 无协程池概念，每次创建新协程
- libaco: 简单的协程复用，但状态管理不完善
- libco-oop: 完整的协程池系统，智能资源管理

#### 生产环境考虑因素

**性能目标**:
- 协程获取延迟 < 100ns (从池中获取)
- 协程重置时间 < 50ns
- 内存碎片率 < 5%
- 池命中率 > 95%

**运维要求**:
- 支持运行时池大小调整
- 提供详细的使用统计和监控
- 支持池性能分析和调优
- 提供内存泄漏检测和自动清理

**容错和恢复**:
- 池满时的降级策略 (直接创建新协程)
- 异常协程的检测和清理
- 内存压力下的自动缩减
- 协程泄漏的检测和预警

#### 子任务清单

##### 8.1 设计协程池架构
- 定义 CoroutinePool 类接口
- 实现协程的复用机制
- 设计资源回收策略

**AI助手提示词**:
```
请帮我设计 libco-oop 的协程池系统：

1. 在 include/libco_oop/coroutine_pool.h 中定义：
   - CoroutinePool 类接口
   - 协程复用策略枚举
   - 资源管理配置结构

2. 核心功能：
   - get_coroutine() - 获取可用协程
   - return_coroutine() - 归还协程到池中
   - resize_pool() - 动态调整池大小
   - get_statistics() - 获取使用统计

3. 设计要求：
   - 支持不同大小的协程栈
   - 实现协程的预分配和复用
   - 提供详细的使用统计信息

请设计一个高效且灵活的协程池系统。
```

##### 8.2 实现协程复用逻辑
- 实现协程的创建和复用
- 处理协程状态重置
- 实现智能的池大小管理

**AI助手提示词**:
```
请帮我实现协程池的核心功能：

1. 在 src/core/coroutine_pool.cpp 中实现：
   - CoroutinePool 类的完整实现
   - 协程的预分配和复用逻辑
   - 动态池大小调整算法

2. 实现要点：
   - 协程状态的完全重置
   - 栈内存的清理和复用
   - 池中协程的生命周期管理
   - 线程安全的池操作

3. 优化策略：
   - 根据使用模式调整池大小
   - 实现协程的预热机制
   - 监控和统计协程使用情况

请确保协程池能显著提升性能。
```

##### 8.3 协程池测试和基准
- 编写协程池功能测试
- 实现性能基准测试
- 验证资源管理正确性

**AI助手提示词**:
```
请为协程池编写全面的测试和基准：

1. 在 tests/unit/test_coroutine_pool.cpp 中创建：
   - 协程池基本功能测试
   - 协程复用正确性测试
   - 池大小动态调整测试
   - 资源泄漏检测测试

2. 在 tests/benchmark/bench_coroutine_pool.cpp 中创建：
   - 协程创建性能对比 (池 vs 直接创建)
   - 大量协程并发测试
   - 内存使用效率测试

3. 测试场景：
   - 高频协程创建/销毁场景
   - 不同工作负载下的性能表现
   - 长时间运行的稳定性测试

请确保协程池在各种场景下都能正确工作。
```

#### 验收标准
- [ ] CoroutinePool 类设计和实现完成
- [ ] 协程复用机制正常工作
- [ ] 性能相比直接创建有显著提升
- [ ] 资源管理无泄漏
- [ ] 所有测试和基准通过

#### 注意事项
- 协程重置要彻底清理状态
- 池大小调整要考虑内存压力
- 要支持多线程环境下的使用
- 统计信息要准确和有用

---

### TASK009: 生产环境优化
**版本**: 3.0
**状态**: 🔲 未开始
**优先级**: 中
**预计时间**: 6-8小时

#### 技术决策说明
**为什么这样设计**:
- 生产环境优化是协程库从实验室走向实际应用的关键步骤
- 全面的性能监控和调试支持，降低生产环境运维成本
- 深度的性能分析和调优，确保协程库在高负载下稳定运行
- 完整的文档和示例，降低用户学习和使用成本

**关键技术点**:
- 零开销的性能监控和统计
- 生产级别的内存管理和泄漏检测
- 实时的性能分析和瓶颈定位
- 完整的故障诊断和恢复机制

#### 生产环境检查清单

**性能要求**:
- [ ] 协程创建性能达到目标 (< 1μs)
- [ ] 上下文切换性能达到目标 (< 20ns)
- [ ] IO事件处理延迟达到目标 (< 1ms)
- [ ] 内存使用效率达到目标 (< 4KB per协程)
- [ ] CPU使用效率 > 95%

**稳定性要求**:
- [ ] 长时间运行无内存泄漏
- [ ] 高并发场景稳定运行 (>10K协程)
- [ ] 错误恢复机制完善
- [ ] 异常情况处理正确
- [ ] 资源耗尽时优雅降级

**可观测性要求**:
- [ ] 详细的性能指标监控
- [ ] 实时的协程状态查询
- [ ] 完整的调用链跟踪
- [ ] 智能的异常检测和报警
- [ ] 可视化的性能分析工具

**文档完整性要求**:
- [ ] 完整的API参考文档
- [ ] 详细的使用教程和示例
- [ ] 最佳实践和性能调优指南
- [ ] 故障排除和问题诊断手册
- [ ] 与其他库的对比和迁移指南

#### 子任务清单

##### 9.1 性能分析和优化
- 实现性能监控系统
- 优化关键路径性能
- 添加性能调优接口

**AI助手提示词**:
```
请帮我为 libco-oop 添加性能监控和优化：

1. 在 include/libco_oop/profiler.h 中定义：
   - Profiler 类 (性能分析器)
   - 性能指标收集接口
   - 性能报告生成功能

2. 监控指标：
   - 协程创建/销毁次数和耗时
   - 上下文切换次数和耗时
   - IO 事件处理延迟
   - 内存使用情况

3. 优化目标：
   - 减少上下文切换开销
   - 优化内存分配模式
   - 提高 IO 事件处理效率
   - 减少系统调用次数

请设计一个轻量级但功能完整的性能监控系统。
```

##### 9.2 调试和诊断支持
- 实现协程调试接口
- 添加运行时诊断功能
- 支持协程状态可视化

**AI助手提示词**:
```
请帮我为 libco-oop 添加调试和诊断支持：

1. 在 include/libco_oop/debug.h 中定义：
   - DebugManager 类
   - 协程状态查询接口
   - 运行时诊断功能

2. 调试功能：
   - 协程调用栈跟踪
   - 协程状态转换日志
   - 死锁检测和报告
   - 资源使用情况监控

3. 诊断工具：
   - 协程状态转储
   - 调度器状态查询
   - 性能瓶颈分析
   - 内存泄漏检测

请确保调试功能对性能影响最小。
```

##### 9.3 文档和示例完善
- 编写完整的 API 文档
- 创建使用示例和教程
- 添加最佳实践指南

**AI助手提示词**:
```
请帮我完善 libco-oop 的文档和示例：

1. 在 docs/ 目录下创建：
   - API 参考文档 (使用 Doxygen)
   - 用户指南和教程
   - 最佳实践文档
   - 故障排除指南

2. 在 examples/ 目录下创建：
   - 基础协程使用示例
   - IO 密集型应用示例
   - 高性能服务器示例
   - 协程池使用示例

3. 文档内容：
   - 详细的 API 说明和示例
   - 性能调优建议
   - 常见问题和解决方案
   - 与其他协程库的对比

请确保文档清晰易懂，示例代码可以直接运行。
```

#### 验收标准
- [ ] 性能监控系统实现完成
- [ ] 调试和诊断功能正常工作
- [ ] 完整的文档和示例
- [ ] 生产环境性能达标
- [ ] 所有功能稳定可靠

#### 注意事项
- 性能监控要可配置开关
- 调试功能要支持远程诊断
- 文档要与代码保持同步
- 示例要覆盖典型使用场景

---

## 开发里程碑总结

### 1.0 版本里程碑
- **目标**: 实现基础协程功能
- **关键任务**: TASK001-TASK005
- **验收标准**: 基础协程创建、切换、调度功能完整
- **预计工期**: 4-6 周

### 2.0 版本里程碑
- **目标**: 增加 IO 调度和定时器功能
- **关键任务**: TASK006-TASK007
- **验收标准**: 支持网络 IO 和定时器的协程调度
- **预计工期**: 3-4 周

### 3.0 版本里程碑
- **目标**: 生产就绪的完整功能
- **关键任务**: TASK008-TASK009
- **验收标准**: 性能优化、监控、调试功能完整
- **预计工期**: 4-5 周

## 附录A：常用AI助手提示词模板

### 架构决策记录模板
```
**ADR-XXX: [决策标题]**
- **决策**: [最终决策内容]
- **背景**: [需要做出决策的背景和问题]
- **备选方案**:
  - 方案A: [描述和优缺点]
  - 方案B: [描述和优缺点]
  - 方案C: [描述和优缺点]
- **决策理由**: [选择该方案的技术和业务理由]
- **风险缓解**: [如何降低该决策的风险]
- **后续行动**: [需要采取的后续措施]
```

### 性能基准测试模板
```
**性能基准: [组件名称]**
- **测试环境**: [硬件配置、操作系统、编译器版本]
- **性能目标**: [具体的性能指标和目标值]
- **测试场景**: [具体的测试案例和参数]
- **基准结果**: [实际测试结果和对比数据]
- **优化建议**: [进一步的性能优化方向]
```

### 代码实现模板
```
请帮我实现 [组件名称] 的 [具体功能]：

任务背景：[技术背景和目标说明]

具体要求：
1. [功能要求1]
2. [功能要求2]
3. [性能要求]
4. [接口设计要求]

文件路径：[精确的文件路径]

参考实现：[参考libco/libaco的具体实现或其他参考]

验证方法：[如何验证实现正确性]

依赖检查：[需要确认的前置条件]
```

### 测试用例模板
```
请为 [组件名称] 编写全面的测试用例：

任务背景：[测试目标和重要性说明]

测试场景：
1. [正常功能测试]
2. [边界条件测试]
3. [错误处理测试]
4. [性能基准测试]

文件路径：tests/unit/test_[组件名].cpp

验证标准：[测试通过的具体标准]

依赖检查：[测试运行的前置条件]
```

### 文档编写模板
```
请为 [组件名称] 编写技术文档：

文档目标：[文档的目的和受众]

内容要求：
1. [技术原理说明]
2. [API接口文档]
3. [使用示例]
4. [最佳实践]

文件路径：docs/[文档类型]/[文档名].md

参考标准：[文档格式和质量标准]
```

## 附录B：故障排除指南

### 常见编译问题
1. **汇编代码编译错误**
   - 症状：汇编语法错误或链接失败
   - 原因：汇编语法不兼容或符号未导出
   - 解决：检查汇编语法，确认符号导出正确

2. **头文件包含错误**
   - 症状：找不到头文件或循环包含
   - 原因：包含路径配置错误或头文件依赖问题
   - 解决：检查xmake.lua中的包含路径配置

### 常见测试问题
1. **测试用例失败**
   - 症状：特定测试用例不通过
   - 调试：使用gdb调试测试程序
   - 修复：分析失败原因，修复实现或测试

2. **内存泄漏检测**
   - 症状：valgrind报告内存泄漏
   - 调试：分析泄漏调用栈
   - 修复：确保RAII和正确的资源管理

### AI助手协作问题
1. **提示词不够明确**
   - 问题：AI助手理解不准确
   - 解决：使用标准模板，提供更详细的背景

2. **依赖关系不清楚**
   - 问题：任务执行顺序错误
   - 解决：检查前置条件清单，确认依赖完成

## 附录C：性能目标和基准

### 性能目标
- **上下文切换**: < 20ns (x86_64, 3GHz CPU)
- **协程创建**: < 1μs (使用协程池)
- **内存使用**: < 4KB per 协程 (独立栈模式)
- **调度延迟**: < 100μs (IO事件响应)

### 基准测试标准
- 使用Google Benchmark框架
- 在发布模式下测试 (-O2优化)
- 多次运行取平均值
- 与libco/libaco性能对比

## 总体注意事项

1. **测试驱动**: 每个功能都要先写测试用例，确保质量
2. **渐进开发**: 确保每个版本都是可用的，避免大爆炸式开发
3. **性能优先**: 关键路径要保持高性能，定期进行性能测试
4. **文档同步**: 代码和文档要同步更新，保持一致性
5. **代码审查**: 重要功能要进行代码审查，确保质量
6. **AI协作**: 充分利用AI助手，但要验证生成的代码
7. **安全考虑**: 注意内存安全、线程安全和异常安全
8. **平台兼容**: 考虑不同平台和编译器的兼容性

---

## 📋 DEV_PLAN.md 完善状态总结

### ✅ 已完成的改进
1. **AI助手协作指南**: 添加了标准化的指令格式和执行流程
2. **任务状态跟踪**: 建立了完整的进度跟踪系统
3. **技术架构决策**: 添加了与libco/libaco的对比分析
4. **标准化模板**: 创建了AI提示词、测试用例等标准模板
5. **故障排除指南**: 添加了常见问题和解决方案
6. **性能目标**: 定义了明确的性能基准和测试标准

### ✅ 已标准化的任务 (3/9)
- **TASK001**: 项目基础设施搭建 - 完全标准化
- **TASK002**: 协程上下文管理实现 - 完全标准化
- **TASK003**: 协程栈管理系统 - 完全标准化

### 🔄 部分标准化的任务 (1/9)
- **TASK004**: 基础协程类实现 - 接口设计部分已标准化

### 🔲 待标准化的任务 (5/9)
- **TASK005**: 简单调度器实现
- **TASK006**: IO事件驱动调度
- **TASK007**: 定时器系统实现
- **TASK008**: 协程池和资源管理
- **TASK009**: 生产环境优化

### 📈 改进效果
1. **可执行性**: 每个任务都有明确的AI指令和验证标准
2. **教学性**: 增加了技术背景和原理解释
3. **完整性**: 包含了前置条件、验收标准和故障排除
4. **实用性**: 提供了标准模板和最佳实践指南

### 🎯 下一步行动
要完成整个DEV_PLAN.md的标准化，建议按以下顺序继续：

1. **立即执行**: 使用已标准化的TASK001开始项目搭建
2. **继续标准化**: 完成TASK004-009的标准化工作
3. **验证测试**: 在实际使用中验证AI提示词的有效性
4. **持续改进**: 根据使用反馈优化提示词和流程

### 💡 使用建议
1. **按顺序执行**: 严格按照TASK001→TASK002→TASK003的顺序进行
2. **验证前置条件**: 每个任务开始前都要检查前置条件清单
3. **使用标准模板**: 复制粘贴AI提示词，确保指令准确
4. **及时更新状态**: 完成任务后及时更新进度跟踪表
5. **记录问题**: 遇到问题时参考故障排除指南并记录解决方案

这个完善后的DEV_PLAN.md现在已经成为一个真正可执行的、AI助手友好的协程库开发指南！🚀
